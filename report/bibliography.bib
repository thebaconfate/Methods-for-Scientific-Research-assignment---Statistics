@inproceedings{TacklingtheAwkwardSquad,
author = {Van den Vonder, Sam and De Koster, Joeri and Myter, Florian and De Meuter, Wolfgang},
title = {Tackling the Awkward Squad for Reactive Programming: The Actor-Reactor Model},
year = {2017},
isbn = {9781450355155},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3141858.3141863},
doi = {10.1145/3141858.3141863},
abstract = {In his famous paper entitled "Tackling the Awkward Squad", Peyton Jones studies how features that traditionally did not fit in the functional programming paradigm can be added to a functional language via careful language design (e.g. using monads), instead of allowing programmers to sprinkle around impure expressions and ad-hoc library calls, thereby turning the entire program into a non-functional program. Similarly, in this paper, we identify a number of code characteristics that do not map onto the reactive programming paradigm but that are present in many real life reactive programs. We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.},
booktitle = {Proceedings of the 4th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems},
pages = {27–33},
numpages = {7},
keywords = {functional reactive programming, the actor-reactor model, actors, reactors},
location = {Vancouver, BC, Canada},
series = {REBLS 2017}
}

@article{reactmanifesto,
    author = "{Jonas Bonér, Dave Farley, Roland Kuhn, and Martin Thompson.}",
    title = "{The Reactive Manifesto}",
    year = "{2014}",
    url = "{https://www.reactivemanifesto.org/}"
}

@article{ScalaLoci,
author = {Weisenburger, Pascal and K\"{o}hler, Mirko and Salvaneschi, Guido},
title = {Distributed System Development with ScalaLoci},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276499},
doi = {10.1145/3276499},
abstract = {Distributed applications are traditionally developed as separate modules, often in different languages, which react to events, like user input, and in turn produce new events for the other modules. Separation into components requires time-consuming integration. Manual implementation of communication forces programmers to deal with low-level details. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. The ScalaLoci distributed programming language addresses these issues with a coherent model based on placement types that enables reasoning about distributed data flows, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions. As we show, ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {129},
numpages = {30},
keywords = {Scala, Distributed Programming, Multitier Programming, Reactive Programming, Placement Types}
}

@article{distrireact, 
author = {"Sam Van den Vonder and Thierry Renaux and Wolfgang De Meuter"},
title = {"Topology-Level Reactivity in Distributed Reactive Programs"},
year = {2022},
DOI = {https://doi.org/10.22152/programming-journal.org/2022/6/14}
}

@article{edgeoniot,
title = {Impact of Edge Computing Paradigm on Energy Consumption in IoT},
journal = {IFAC-PapersOnLine},
volume = {51},
number = {6},
pages = {162-167},
year = {2018},
note = {15th IFAC Conference on Programmable Devices and Embedded Systems PDeS 2018},
issn = {2405-8963},
doi = {https://doi.org/10.1016/j.ifacol.2018.07.147},
url = {https://www.sciencedirect.com/science/article/pii/S2405896318308917},
author = {Jozef Mocnej and Martin Miškuf and Peter Papcun and Iveta Zolotová},
keywords = {IoT, Edge Computing, Energy Consumption, ESP Module, Value Prediction},
abstract = {The exponential growth of devices connected to the Internet, the diversity of the Internet of Things (IoT) paradigm, and the variety of IoT protocol stacks are all factors arising concerns about IoT sustainability. A promising solution seems to be IoT integration platforms, which provide the foundation for managing connected devices in a standardized way. The first wave of IoT platforms has been driven by cloud computing with all the logic in the cloud, yet taking a part of the logic to the edge might be a more suitable approach for many use cases. The edge computing paradigm is going to be the next step in the evolution of IoT platforms, but its initial complexity requires further research work to fully comprehend all potential benefits. This paper describes the utilization of edge computing in the IoT and analyzes its impact on energy consumption of IoT devices. The practical case study provided in this paper evaluates the overhead caused by computation at the edge and presents a possible implementation of the edge computing paradigm to positively influence the lifespan of constrained devices powered by batteries.}
}

@INPROCEEDINGS{BuildIoT,
  author={de Troyer, Christophe and Nicolay, Jens and de Meuter, Wolfgang},
  booktitle={2018 IEEE International Conference on Cloud Computing Technology and Science (CloudCom)}, 
  title={Building IoT Systems Using Distributed First-Class Reactive Programming}, 
  year={2018},
  volume={},
  number={},
  pages={185-192},
  doi={10.1109/CloudCom2018.2018.00045}}

@article{edgevscloud,
title = {Edge computing vs centralized cloud: Impact of communication latency on the energy consumption of LTE terminal nodes},
journal = {Computer Communications},
volume = {194},
pages = {213-225},
year = {2022},
issn = {0140-3664},
doi = {https://doi.org/10.1016/j.comcom.2022.07.026},
url = {https://www.sciencedirect.com/science/article/pii/S0140366422002730},
author = {Chiara Caiazza and Silvia Giordano and Valerio Luconi and Alessio Vecchio},
keywords = {Edge computing, Energy saving, IoT communication},
abstract = {Edge computing brings several advantages, such as reduced latency, increased bandwidth, and improved locality of traffic. One aspect that is not sufficiently understood is to what extent the different communication latency experienced in the edge-cloud continuum impacts on the energy consumption of clients. We studied the energy consumption of a request–response communication scheme when an LTE node communicates with edge-based or cloud-based servers. Results show that the reduced latency of edge servers bring significant benefits in terms of energy consumption. Experiments also show how the energy savings brought by edge computing are influenced by the prevalent direction of data transfer (upload vs download), load of the server, and daytime/nighttime operation.}
}

@article{FRP,
author = {Wan, Zhanyong and Hudak, Paul},
title = {Functional Reactive Programming from First Principles},
year = {2000},
issue_date = {May 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {5},
issn = {0362-1340},
url = {https://doi.org/10.1145/358438.349331},
doi = {10.1145/358438.349331},
abstract = {Functional Reactive Programming, or FRP, is a general framework for programming hybrid systems in a high-level, declarative manner. The key ideas in FRP are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are time-ordered sequences of discrete-time event occurrences. FRP is the essence of Fran, a domain-specific language embedded in Haskell for programming reactive animations, but FRP is now also being used in vision, robotics and other control systems applications. In this paper we explore the formal semantics of FRP and how it relates to an implementation based on streams that represent (and therefore only approximate) continuous behaviors. We show that, in the limit as the sampling interval goes to zero, the implementation is faithful to the formal, continuous semantics, but only when certain constraints on behaviors are observed. We explore the nature of these constraints, which vary amongst the FRP primitives. Our results show both the power and limitations of this approach to language design and implementation. As an example of a limitation, we show that streams are incapable of representing instantaneous predicate events over behaviors.},
journal = {SIGPLAN Not.},
month = {may},
pages = {242–252},
numpages = {11}
}

@book{IaC,
    author = "Kief Morris",
    title = "Infrastructure as Code",
    edition = "Third edition",
    publisher = "O'Reilly Media, Inc.",
    year = "2020",
    ISBN = "9781491924358"
}

@misc{cruz2021tools,
  title = {Tools to Measure Software Energy Consumption from your Computer},
  author = {Lu\'{i}s Cruz},
  year = {2021},
  howpublished={\url{http://luiscruz.github.io/2021/07/20/measuring-energy.html}},
  doi = {10.6084/m9.figshare.19145549.v1},
  note = {Blog post.}
}

@misc{AkkaStream, 
title = "Akka Streams: Working with Graphs",
author = "Lightbend, Inc.",
url = "https://doc.akka.io/docs/akka/current/stream/stream-graphs.html#introduction"

}

